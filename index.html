<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Explorer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        
        /* Экран загрузки */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s ease-out;
        }
        #loading-text {
            color: white;
            font-size: 24px;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }
        #loading-status {
            color: #2196F3;
            font-size: 14px;
            margin-top: 10px;
            font-family: monospace;
        }
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #2196F3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none; 
        }
        h2 { margin-top: 0; font-size: 18px; text-transform: uppercase; letter-spacing: 2px; }
        .btn-group { display: flex; flex-wrap: wrap; gap: 10px; max-width: 350px; }
        button {
            background: transparent;
            border: 1px solid white;
            color: white;
            padding: 8px 15px;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 4px;
            text-transform: uppercase;
            font-size: 11px;
        }
        button:hover {
            background: white;
            color: black;
        }
        button.active {
            background: #2196F3;
            border-color: #2196F3;
            color: white;
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div id="loading-text">Идет загрузка текстур...</div>
        <div class="spinner"></div>
        <div id="loading-status">Подготовка ресурсов...</div>
    </div>

    <div id="ui-layer">
        <h2>Выберите планету</h2>
        <div class="btn-group">
            <button id="btn-mercury" onclick="switchPlanet('mercury')">Меркурий</button>
            <button id="btn-venus" onclick="switchPlanet('venus')">Венера</button>
            <button id="btn-earth" onclick="switchPlanet('earth')">Земля</button>
            <button id="btn-mars" onclick="switchPlanet('mars')">Марс</button>
            <button id="btn-jupiter" onclick="switchPlanet('jupiter')">Юпитер</button>
            <button id="btn-saturn" onclick="switchPlanet('saturn')">Сатурн</button>
            <button id="btn-uranus" onclick="switchPlanet('uranus')">Уран</button>
            <button id="btn-neptune" onclick="switchPlanet('neptune')">Нептун</button>
            <button id="btn-pluto" onclick="switchPlanet('pluto')">Плутон</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let sunLight;
        
        let mercuryGroup, venusGroup, earthGroup, marsGroup, jupiterGroup, saturnGroup, uranusGroup, neptuneGroup, plutoGroup;
        let currentPlanet = 'earth';

        let mercury, venus, earth, moon, moonPivot, clouds;
        let mars, phobosPivot, deimosPivot;
        let jupiter, ioPivot, europaPivot, ganymedePivot, callistoPivot;
        let saturn, saturnRings, titanPivot;
        let uranus;
        let neptune;
        let pluto, charonPivot;

        let texturesLoaded = false;
        let itemsLoaded = 0;
        let itemsTotal = 0;

        // Настройка прокси
        const proxy = "https://images.weserv.nl/?url=";
        const getTexturePath = (url) => proxy + encodeURIComponent(url);
        
        const TEXTURES = {
            mercury: "https://cosmos-online.ru/wp-content/uploads/2018/10/2k_mercury.jpg",
            venus: "https://cosmos-online.ru/wp-content/uploads/2018/10/2k_venus_atmosphere.jpg",
            earthDay: "https://cosmos-online.ru/wp-content/uploads/2018/10/2k_earth_daymap.jpg",
            earthNight: "https://cosmos-online.ru/wp-content/uploads/2018/10/2k_earth_nightmap.jpg",
            moon: "https://cosmos-online.ru/wp-content/uploads/2018/10/2k_moon.jpg",
            mars: "https://cosmos-online.ru/wp-content/uploads/2018/10/2k_mars.jpg",
            jupiter: "https://cosmos-online.ru/wp-content/uploads/2018/10/2k_jupiter.jpg",
            io: "https://textur.gas-kvas.com/uploads/posts/2024-10/textur-gas-kvas-com-l2s3-p-teksturi-sputniki-yupitera-1.jpg",
            europa: "https://textur.gas-kvas.com/uploads/posts/2024-10/textur-gas-kvas-com-l478-p-teksturi-sputniki-yupitera-3.jpg",
            ganymede: "https://textur.gas-kvas.com/uploads/posts/2024-10/textur-gas-kvas-com-l4mc-p-teksturi-sputniki-yupitera-5.jpg",
            callisto: "https://textur.gas-kvas.com/uploads/posts/2024-10/textur-gas-kvas-com-l4hw-p-teksturi-sputniki-yupitera-4.jpg",
            saturn: "https://cosmos-online.ru/wp-content/uploads/2018/10/2k_saturn.jpg",
            saturnRings: "https://cosmos-online.ru/wp-content/uploads/2018/10/2k_saturn_ring_alpha.png",
            titan: "https://textur.gas-kvas.com/uploads/posts/2024-10/textur-gas-kvas-com-n097-p-teksturi-titana-sputnik-2.jpg",
            uranus: "https://cosmos-online.ru/wp-content/uploads/2018/10/2k_uranus.jpg",
            neptune: "https://cosmos-online.ru/wp-content/uploads/2018/10/2k_neptune.jpg",
            pluto: "https://textur.gas-kvas.com/uploads/posts/2024-10/thumbs/textur-gas-kvas-com-kdb2-p-teksturi-plutona-2.jpg",
            charon: "https://textur.gas-kvas.com/uploads/posts/2024-10/textur-gas-kvas-com-kel2-p-teksturi-plutona-8.jpg"
        };

        const PLANET_RADII = {
            mercury: 2.5,
            venus: 4.8,
            earth: 5.4,
            mars: 4.8,
            jupiter: 15.0,
            saturn: 12.0,
            uranus: 10.0,
            neptune: 9.8,
            pluto: 2.2
        };

        const atmosphereVertex = `
            varying vec3 vNormal;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const atmosphereFragment = `
            varying vec3 vNormal;
            uniform vec3 atmosphereColor;
            void main() {
                float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                gl_FragColor = vec4(atmosphereColor, 1.0) * intensity;
            }
        `;

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2500);
            camera.position.set(40, 30, 80);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 500;
            controls.enablePan = false; 
            controls.target.set(0, 0, 0); 
            
            sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(50, 20, 30);
            scene.add(sunLight);

            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

            // Настройка менеджера загрузки
            const manager = new THREE.LoadingManager();
            const statusEl = document.getElementById('loading-status');

            manager.onProgress = function (url, itemsL, itemsT) {
                itemsLoaded = itemsL;
                itemsTotal = itemsT;
                statusEl.innerText = `Загружено: ${itemsL} из ${itemsT}`;
            };

            manager.onLoad = function () {
                texturesLoaded = true;
                statusEl.innerText = "Все текстуры загружены. Запуск...";
            };

            const loader = new THREE.TextureLoader(manager);
            loader.setCrossOrigin('anonymous');

            const createMoon = (radius, dist, textureUrl) => {
                const tex = loader.load(getTexturePath(textureUrl));
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), new THREE.MeshPhongMaterial({ map: tex }));
                mesh.position.set(dist, 0, 0);
                const pivot = new THREE.Group();
                pivot.add(mesh);
                return pivot;
            };

            // Создание планет
            mercuryGroup = new THREE.Group();
            mercuryGroup.visible = false;
            mercury = new THREE.Mesh(new THREE.SphereGeometry(2.5, 64, 64), new THREE.MeshPhongMaterial({ map: loader.load(getTexturePath(TEXTURES.mercury)), shininess: 2 }));
            mercuryGroup.add(mercury);
            scene.add(mercuryGroup);

            venusGroup = new THREE.Group();
            venusGroup.visible = false;
            venus = new THREE.Mesh(new THREE.SphereGeometry(4.8, 64, 64), new THREE.MeshPhongMaterial({ map: loader.load(getTexturePath(TEXTURES.venus)), shininess: 5 }));
            venusGroup.add(venus);
            scene.add(venusGroup);

            earthGroup = new THREE.Group();
            earthGroup.visible = true;
            const earthDayTex = loader.load(getTexturePath(TEXTURES.earthDay));
            const earthNightTex = loader.load(getTexturePath(TEXTURES.earthNight));
            const earthShaderMaterial = new THREE.ShaderMaterial({
                uniforms: { sunDirection: { value: sunLight.position.clone().normalize() }, dayTexture: { value: earthDayTex }, nightTexture: { value: earthNightTex } },
                vertexShader: `varying vec2 vUv; varying vec3 vNormal; varying vec3 vSunDirection; void main() { vUv = uv; vNormal = normalize(normalMatrix * normal); vSunDirection = normalize(viewMatrix * vec4(50.0, 20.0, 30.0, 0.0)).xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                fragmentShader: `uniform sampler2D dayTexture; uniform sampler2D nightTexture; varying vec2 vUv; varying vec3 vNormal; varying vec3 vSunDirection; void main() { float intensity = dot(vNormal, normalize(vSunDirection)); vec4 dayColor = texture2D(dayTexture, vUv); vec4 nightColor = texture2D(nightTexture, vUv); float mixAmount = smoothstep(-0.25, 0.25, intensity); gl_FragColor = mix(nightColor, dayColor, mixAmount); }`
            });
            earth = new THREE.Mesh(new THREE.SphereGeometry(5, 64, 64), earthShaderMaterial);
            earthGroup.add(earth);
            const cloudShaderMaterial = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, sunDirection: { value: sunLight.position.clone().normalize() } },
                vertexShader: `varying vec2 vUv; varying vec3 vNormal; varying vec3 vSunDirection; void main() { vUv = uv; vNormal = normalize(normalMatrix * normal); vSunDirection = normalize(viewMatrix * vec4(50.0, 20.0, 30.0, 0.0)).xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                fragmentShader: `varying vec2 vUv; varying vec3 vNormal; varying vec3 vSunDirection; uniform float uTime; float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); } float noise(vec2 p) { vec2 i = floor(p); vec2 f = fract(p); f = f*f*(3.0-2.0*f); return mix(mix(hash(i), hash(i+vec2(1,0)), f.x), mix(hash(i+vec2(0,1)), hash(i+vec2(1,1)), f.x), f.y); } float fbm(vec2 p) { float v = 0.0; float a = 0.5; for (int i=0; i<8; i++) { v += a * noise(p); p *= 2.2; a *= 0.5; } return v; } void main() { vec2 p = vUv * 25.0; p.x += uTime * 0.015; float n = fbm(p); float cloudFactor = smoothstep(0.5, 0.75, n); float lightIntensity = dot(vNormal, vSunDirection); float alpha = cloudFactor * smoothstep(-0.3, 0.3, lightIntensity) * 0.5; if (alpha < 0.01) discard; gl_FragColor = vec4(1.0, 1.0, 1.0, alpha); }`,
                transparent: true, depthWrite: false
            });
            clouds = new THREE.Mesh(new THREE.SphereGeometry(5.15, 64, 64), cloudShaderMaterial);
            earthGroup.add(clouds);
            const earthAtmosphere = new THREE.Mesh(new THREE.SphereGeometry(5.4, 64, 64), new THREE.ShaderMaterial({ vertexShader: atmosphereVertex, fragmentShader: atmosphereFragment, uniforms: { atmosphereColor: { value: new THREE.Color(0x3399ff) } }, side: THREE.BackSide, transparent: true }));
            earthGroup.add(earthAtmosphere);
            moonPivot = createMoon(1.3, 18, TEXTURES.moon);
            earthGroup.add(moonPivot);
            scene.add(earthGroup);

            marsGroup = new THREE.Group();
            marsGroup.visible = false;
            mars = new THREE.Mesh(new THREE.SphereGeometry(4.5, 64, 64), new THREE.MeshPhongMaterial({ map: loader.load(getTexturePath(TEXTURES.mars)) }));
            marsGroup.add(mars);
            const marsAtmosphere = new THREE.Mesh(new THREE.SphereGeometry(4.8, 64, 64), new THREE.ShaderMaterial({ vertexShader: atmosphereVertex, fragmentShader: atmosphereFragment, uniforms: { atmosphereColor: { value: new THREE.Color(0xffaa88) } }, side: THREE.BackSide, transparent: true }));
            marsGroup.add(marsAtmosphere);
            phobosPivot = new THREE.Group();
            const phobos = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), new THREE.MeshPhongMaterial({ color: 0x887766 }));
            phobos.position.set(7.5, 0, 0);
            phobosPivot.add(phobos);
            deimosPivot = new THREE.Group();
            const deimos = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), new THREE.MeshPhongMaterial({ color: 0x998877 }));
            deimos.position.set(11, 0, 0);
            deimosPivot.add(deimos);
            marsGroup.add(phobosPivot, deimosPivot);
            scene.add(marsGroup);

            jupiterGroup = new THREE.Group();
            jupiterGroup.visible = false;
            jupiter = new THREE.Mesh(new THREE.SphereGeometry(15, 64, 64), new THREE.MeshPhongMaterial({ map: loader.load(getTexturePath(TEXTURES.jupiter)) }));
            jupiterGroup.add(jupiter);
            ioPivot = createMoon(0.8, 25, TEXTURES.io);
            europaPivot = createMoon(0.7, 32, TEXTURES.europa);
            ganymedePivot = createMoon(1.2, 42, TEXTURES.ganymede);
            callistoPivot = createMoon(1.1, 55, TEXTURES.callisto);
            jupiterGroup.add(ioPivot, europaPivot, ganymedePivot, callistoPivot);
            scene.add(jupiterGroup);

            saturnGroup = new THREE.Group();
            saturnGroup.visible = false;
            saturn = new THREE.Mesh(new THREE.SphereGeometry(12, 64, 64), new THREE.MeshPhongMaterial({ map: loader.load(getTexturePath(TEXTURES.saturn)) }));
            saturnGroup.add(saturn);
            const ringTex = loader.load(getTexturePath(TEXTURES.saturnRings));
            const ringGeo = new THREE.RingGeometry(15, 28, 128);
            const ringUv = ringGeo.attributes.uv;
            for (let i = 0; i < ringGeo.attributes.position.count; i++) {
                const x = ringGeo.attributes.position.getX(i);
                const y = ringGeo.attributes.position.getY(i);
                const dist = Math.sqrt(x*x + y*y);
                const u = (dist - 15) / (28 - 15);
                ringUv.setXY(i, u, 0);
            }
            saturnRings = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({ map: ringTex, side: THREE.DoubleSide, transparent: true, opacity: 0.8 }));
            saturnRings.rotation.x = Math.PI / 2;
            saturnGroup.add(saturnRings);
            titanPivot = createMoon(1.4, 45, TEXTURES.titan);
            saturnGroup.add(titanPivot);
            scene.add(saturnGroup);

            uranusGroup = new THREE.Group();
            uranusGroup.visible = false;
            uranus = new THREE.Mesh(new THREE.SphereGeometry(10, 64, 64), new THREE.MeshPhongMaterial({ map: loader.load(getTexturePath(TEXTURES.uranus)) }));
            uranus.rotation.x = Math.PI / 2; 
            uranusGroup.add(uranus);
            scene.add(uranusGroup);

            neptuneGroup = new THREE.Group();
            neptuneGroup.visible = false;
            neptune = new THREE.Mesh(new THREE.SphereGeometry(9.8, 64, 64), new THREE.MeshPhongMaterial({ map: loader.load(getTexturePath(TEXTURES.neptune)) }));
            neptuneGroup.add(neptune);
            scene.add(neptuneGroup);

            plutoGroup = new THREE.Group();
            plutoGroup.visible = false;
            const plutoTex = loader.load(getTexturePath(TEXTURES.pluto));
            pluto = new THREE.Mesh(new THREE.SphereGeometry(2.2, 64, 64), new THREE.MeshPhongMaterial({ map: plutoTex }));
            plutoGroup.add(pluto);
            charonPivot = createMoon(1.8, 5.5, TEXTURES.charon);
            plutoGroup.add(charonPivot);
            scene.add(plutoGroup);

            const starPoints = [];
            for (let i = 0; i < 10000; i++) starPoints.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
            const starGeo = new THREE.BufferGeometry();
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPoints, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.8 })));

            window.addEventListener('resize', onWindowResize, false);
            
            // Периодическая проверка готовности (каждые 0.5 сек)
            const checkReady = setInterval(() => {
                if (texturesLoaded) {
                    clearInterval(checkReady);
                    const loaderScreen = document.getElementById('loading-screen');
                    const uiLayer = document.getElementById('ui-layer');
                    loaderScreen.style.opacity = '0';
                    setTimeout(() => {
                        loaderScreen.style.display = 'none';
                        uiLayer.style.display = 'block';
                    }, 1000);
                }
            }, 500);

            animate();
            switchPlanet('earth');
        }

        function switchPlanet(planet) {
            currentPlanet = planet;
            const btns = ['mercury', 'venus', 'earth', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune', 'pluto'];
            btns.forEach(b => {
                const btn = document.getElementById('btn-' + b);
                if (btn) btn.classList.toggle('active', planet === b);
            });
            
            mercuryGroup.visible = (planet === 'mercury');
            venusGroup.visible = (planet === 'venus');
            earthGroup.visible = (planet === 'earth');
            marsGroup.visible = (planet === 'mars');
            jupiterGroup.visible = (planet === 'jupiter');
            saturnGroup.visible = (planet === 'saturn');
            uranusGroup.visible = (planet === 'uranus');
            neptuneGroup.visible = (planet === 'neptune');
            plutoGroup.visible = (planet === 'pluto');
            
            controls.minDistance = PLANET_RADII[planet] + 1; 
            const currentDist = camera.position.length();
            if (currentDist < controls.minDistance) {
                camera.position.setLength(controls.minDistance + 5);
            }
            controls.update();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);
            const ts = time * 0.001;

            if (currentPlanet === 'mercury') mercury.rotation.y += 0.001;
            else if (currentPlanet === 'venus') venus.rotation.y -= 0.0004;
            else if (currentPlanet === 'earth') { 
                earth.rotation.y += 0.0005; 
                if (clouds) {
                    clouds.rotation.y += 0.0007;
                    clouds.material.uniforms.uTime.value = ts;
                }
                moonPivot.rotation.y += 0.0006; 
            }
            else if (currentPlanet === 'mars') { 
                mars.rotation.y += 0.0008; 
                phobosPivot.rotation.y += 0.005; 
                deimosPivot.rotation.y += 0.002;
            }
            else if (currentPlanet === 'jupiter') { jupiter.rotation.y += 0.0012; ioPivot.rotation.y += 0.008; europaPivot.rotation.y += 0.004; ganymedePivot.rotation.y += 0.002; callistoPivot.rotation.y += 0.001; }
            else if (currentPlanet === 'saturn') { saturn.rotation.y += 0.0015; titanPivot.rotation.y += 0.0004; }
            else if (currentPlanet === 'uranus') { uranus.rotation.z += 0.001; }
            else if (currentPlanet === 'neptune') { neptune.rotation.y += 0.0011; }
            else if (currentPlanet === 'pluto') { 
                pluto.rotation.y += 0.0005; 
                charonPivot.rotation.y += 0.0005; 
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
